00000000000000000000000000001010 //         XOR     r0, r0,    r0           # ゼロレジスタの用意
00000100000010100000000000000000 //         ADDI    r10,    r0,    0        # 変数mの初期化
00000100000111010000010000000000 //         ADDI    r29,    r0,    1024     # スタックポインタの初期化
00000100000011110000001000000000 //         ADDI    r15,    r0,    512      # 32bit定数の用意
00001100000011100000011101011011 //         LUI             r14,    1883    # static x
00010101110011101100110100010101 //         ORI     r14,    r14,    52501
01100001111011100000000000000000 //         SW      r14,    0(r15)
00001100000011100001010110011010 //         LUI             r14,    5530    # static y
00010101110011100101010111100101 //         ORI     r14,    r14,    21989
01100001111011100000000000000100 //         SW      r14,    4(r15)
00001100000011100001111100010010 //         LUI             r14,    7954    # static z
00010101110011100011101110110101 //         ORI     r14,    r14,    15285
01100001111011100000000000001000 //         SW      r14,    8(r15)
00001100000011100000010101001001 //         LUI             r14,    1353    # static w
00010101110011100001001100110011 //         ORI     r14,    r14,    4915
01100001111011100000000000001100 //         SW      r14,    12(r15)
00001100000011100011111111111111 //         LUI             r14,    16383   # static mul16(0x7fff)
00010101110011100000000000000001 //         ORI     r14,    r14,    1
01100001111011100000000000010000 //         SW      r14,    16(r15)
00000100000010000000000000000000 //         ADDI    r8,     r0,    0        # i = 0の変換
00000100000110000000000110010000 //         ADDI    r24,    r0,    400      # iの上限となる定数
10001111000010000000000001110100 // FOR0S:  BLE     r24,    r8,    FOR0E    # for (i = 0; i < 400; i++)    # i < 400（400 <= i）の変換
10100100000000000000000101010100 //         JAL     _xor128                 # forブロック内   # Xorshiftと呼ばれる方法を、関数xor128として使い、乱数を生成
00000000000000101000000000000000 //         ADD     r16,    r0,    r2
00000010000000000111010000010001 //         SRL     r14,    r16,    16
00010001110100011111111111111111 //         ANDI    r17,    r14,    65535
00010010000100101111111111111111 //         ANDI    r18,    r16,    65535
00000010001000001000100001010001 //         SRL     r17,    r17,    1       # オーバーフロー防止のため2でわる
00000010010000001001000001010001 //         SRL     r18,    r18,    1
00000000000100010010000000000000 //         ADD     r4,     r0,    r17      # 2乗を関数powで計算   # pow(x)
01100011101010000000000000000000 //         SW      r8,     0(r29)
00000100000011100000000000000100 //         ADDI    r14,    r0,    4        # スタックポインタの引き算（定数ではビットが足りないことに注意）
00000011101011101110100000000010 //         SUB     r29,    r29,    r14
10100100000000000000000100101100 //         JAL     _pow
00000111101111010000000000000100 //         ADDI    r29,    r29,    4
01000011101010000000000000000000 //         LW      r8,    0(r29)
00000000000000101000100000000000 //         ADD     r17,    r0,    r2
00000000000100100010000000000000 //         ADD     r4,    r0,    r18       # pow(y)
01100011101010000000000000000000 //         SW      r8,    0(r29)
00000100000011100000000000000100 //         ADDI    r14,    r0,    4
00000011101011101110100000000010 //         SUB     r29,    r29,    r14
10100100000000000000000100101100 //         JAL     _pow
00000111101111010000000000000100 //         ADDI    r29,    r29,    4
01000011101010000000000000000000 //         LW      r8,    0(r29)
00000000010100011000100000000000 //         ADD     r17,    r2,    r17
00000100000011110000001000010000 //         ADDI    r15,    r0,    528      # mul16(0x7fff)のロード
01000001111100100000000000000000 //         LW      r18,    0(r15)
10001110010100010000000000000100 //         BLE     r18,    r17,    IF0E    # if (mul16(x) + mul16(y) <= mul16(0x7fff))
00000101010010100000000000000001 //         ADDI    r10,    r10,    1       # ifブロック内
00000101000010000000000000000001 // IF0E:   ADDI    r8,    r8,    1         # i++の変換
10100000000000000000000001010100 //         J       FOR0S
00000100000100010000000000000000 // FOR0E:  ADDI    r17,    r0,    0        # 変数xの再利用
00000100000010000000000000001000 //         ADDI    r8,    r0,    8         # iを負の数として扱えないので、アセンブリではすべて1を加算して扱うものとする # i = 7[+1]の変換
00000100000110000000000000000000 //         ADDI    r24,    r0,    0        # iの下限となる定数
10001101000000000000000001000100 // FOR1S:  BLE     r8,    r0,    FOR1E     # (i = 7[+1]; i[+1] >= 0; i //  // )  # mを16進数で表現する10進数として出力 # i[+1] >= 0（i <= 0）の変換
00000100000100100000000000000001 //         ADDI    r18,    r0,    1        # forブロック内    # 変数yの再利用
00000100000010010000000000000000 //         ADDI    r9,    r0,    0         # j = 0の変換
00000101001011100000000000000001 // FOR2S:  ADDI    r14,    r9,    1        # for (j = 0; j < i[+1]; j++)        # j < i[+1]（i <= (j + 1)）の変換
10001101000011100000000000010100 //         BLE     r8,    r14,    FOR2E
00000010010000000111000011010000 //         SLL     r14,    r18,    3       # forブロック内
00000010010000001001000001010000 //         SLL     r18,    r18,    1
00000001110100101001000000000000 //         ADD     r18,    r14,    r18
00000101001010010000000000000001 //         ADDI    r9,    r9,    1         # j++の変換
10100000000000000000000011100100 //         J       FOR2S
00000010001000001000100100010000 // FOR2E:  SLL     r17,    r17,    4
10001001010100100000000000001100 // WHILE0S:BLT     r10,    r18,    WHILE0E # while (m >= y)  # m >= y（m < y）の変換
00000001010100100101000000000010 //         SUB     r10,    r10,    r18     # whileブロック内
00000110001100010000000000000001 //         ADDI    r17,    r17,    1
10100000000000000000000100000100 //         J       WHILE0S
00000100000011100000000000000001 // WHILE0E:ADDI    r14,    r0,    1        # i[+1] //  // の変換
00000001000011100100000000000010 //         SUB     r8,     r8,    r14
10100000000000000000000011011000 //         J       FOR1S
00000100000011110000001000010000 // FOR1E:  ADDI    r15,    r0,    528      # return x（mul16(0x7fff)の隣に書き込み）
01100001111100010000000000000100 //         SW      r17,    4(r15)
10100000000000000000000110011000 //         J       END
00000100000000100000000000000000 // _pow:   ADDI    r2,     r0,    0        # int pow(int a)  # 変数sumの初期化
00010100000010001000000000000000 //         ORI     r8,     r0,    32768    # bit = 0x8000の変換
10000000000010000000000000011000 // FORPS:  BEQ     r0,     r8,    FORPE    # for (bit = 0x8000; bit; bit = bit >> 1)    # bit（bit != 0）の変換
00000000010000000001000001010000 //         SLL     r2,     r2,    1        # forブロック内
00000000100010000111000000001000 //         AND     r14,    r4,    r8
10000000000011100000000000000100 //         BEQ     r0,     r14,    IFPE    # if (a16 & bit)
00000000010001000001000000000000 //         ADD     r2,     r2,    r4       # ifブロック内
00000001000000000100000001010001 // IFPE:   SRL     r8,     r8,    1        # bit = bit >> 1の変換
10100000000000000000000100110100 //         J       FORPS
10101011111000000000000000000000 // FORPE:  JR      r31                     # return sum
00000100000011110000001000000000 // _xor128:ADDI    r15,    r0,     512     # int xor128()   # _xの読みこみ
01000001111011100000000000000000 //         LW      r14,    0(r15)
00000001110000000101101011010000 //         SLL     r11,    r14,    11      # x ^ (x << 11)の計算
00000001011011100101100000001010 //         XOR     r11,    r11,    r14
01000001111011100000000000000100 //         LW      r14,    4(r15)          # _yの読み込み、_xへの書き込み（_xの次の行であることに注意、以下定数以外繰り返し）
01100001111011100000000000000000 //         SW      r14,    0(r15)
01000001111011100000000000001000 //         LW      r14,    8(r15)
01100001111011100000000000000100 //         SW      r14,    4(r15)
01000001111011100000000000001100 //         LW      r14,    12(r15)
01100001111011100000000000001000 //         SW      r14,    8(r15)
00000001110000000001010011010001 //         SRL     r2,     r14,    19      # (w ^ (w >> 19))の計算
00000000010011100111000000001010 //         XOR     r14,    r2,     r14
00000001011000000001001000010001 //         SRL     r2,     r11,    8       # (t ^ (t >> 8))
00000001011000100101100000001010 //         XOR     r11,    r11,    r2
00000001011011100001000000001010 //         XOR     r2,     r11,    r14
01100001111000100000000000001100 //         SW      r2,     12(r15)
10101011111000000000000000000000 //         JR      r31                     # return w
11111100000000000000000000000000 // END:    HALT
